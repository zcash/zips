::

  ZIP: 248
  Title: Extensible Transaction Format
  Owners: Jack Grigg <jack@znewco.com>
          Kris Nuttycombe <kris@nutty.land>
          Daira-Emma Hopwood <daira@jacaranda.org>
          Schell Scivally <efsubenovex@gmail.com>
  Status: Draft
  Category: Consensus / Wallet
  Created: 2025-12-17
  License: MIT
  Discussions-To: <https://github.com/zcash/zips/pull/1163>
  Pull-Request: <https://github.com/zcash/zips/pull/1156>

Terminology
===========

{Edit this to reflect the key words that are actually used.}
The key words "MUST", "REQUIRED", "MUST NOT", "SHOULD", and "MAY" in this
document are to be interpreted as described in BCP 14 [^BCP14] when, and only
when, they appear in all capitals.

The character § is used when referring to sections of the Zcash Protocol
Specification. [^protocol]

The terms "Mainnet" and "Testnet" are to be interpreted as described in § 3.12
‘Mainnet and Testnet’. [^protocol-networks]

The term "full validator" in this document is to be interpreted as defined in §
3.3 ‘The Block Chain’. [^protocol-blockchain].

The terms below are to be interpreted as follows:

{Term to be defined}

: {Definition.}


Abstract
========

This ZIP proposes an encoding for V6 Zcash transactions that is intended to
reduce the impact of future changes to the Zcash transaction format on the
Zcash ecosystem. It defines a new typecode-length-value encoding for a sequence
of protocol bundles, and a "value balance" map that describes the effect of
each bundle on the transparent chain value balance, much in the same fashion
as the Sapling and Orchard value balance fields have done in the past.

Motivation
==========

In the past, Zcash network upgrades that change the transaction format have
resulted in substantial disruption for wallets and other third-party clients in
the Zcash ecosystem. In order to continue functioning after a network upgrade,
clients were required to upgrade their Zcash transaction parsers to read the
new format, even if the context in which those parsers were being used didn't
need or couldn't make use of newly added transaction data; an example of this
is that transparent-only wallets were forced to update their parsers to
understand the Sapling and Orchard parts of transactions, even if they would
never read or act upon those parts. This has led on occasion to significant
problems in the Zcash ecosystem, including situations where funds have been
locked and rendered unspendable from transparent-only wallets.

For some kinds of changes to consensus features, it's imperative that every
wallet be aware of and be adapted to those changes, and in those cases making a
major (breaking) transaction version update as we've done in the past is
appropriate. For many new features, however, it is possible for a wallet to
continue functioning correctly without having to fully understand a transaction
using that feature. 

For example, if TZEs were to be added to the protocol, it wouild be possible
for wallets to continue operating with transparent/Sapling/Orchard
functionality, ignoring TZE parts. There is substantial precedent for this sort
of behavior; transparent-only hardware wallets are currently still important in
the Zcash ecosystem, and many wallets didn't begin interacting with Orchard
transaction parts until quite a while after Orchard activation. 

After this change to transaction encoding, wallets and other third parties will
not be required to update their transaction parsers in advance of a network
upgrade for the introduction of many (and perhaps most) types of new protocol
features. This will enable the Zcash ecosystem to make smaller and more
incremental network upgrades without breaking existing wallets.

Privacy Implications
====================

This change alters the encoding of transactions, but does not alter the
information content of the transaction. As such, the only implication of this
change is that the use of this transaction format acts as a 1-bit distinguisher
that reveals that the wallet that generated the transaction has been updated to
be aware of the new format. This information leakage is unavoidable for any
transaction format change.

In the future, this change may reduce the amount of information leakage, since
transactions created using the proposed TLV format will include bundles only 
for those protocols for which the transaction modifies chain state. For example,
if this transaction format change is deployed in NU7 and NU8 defines a bundle
type for TZE components, it will not be possible for a chain observer to
distinguish whether or not the wallet that produced an Orchard-only transaction
is one that has been updated to understand the TZE component. Under prior
practices for changing the transaction format, this would have been
distinguishable.

In summary, this proposal provides a net improvement in user privacy in
addition to its other benefits.

Requirements
============

* The transaction format can be parsed without any knowledge of any Zcash
  payment protocols.
* Movement of value into and out of the transparent value pool(s) can be
  understood with only partial knowledge of the Zcash payment protocols.


Non-requirements
================


Specification
=============

Sketch of the format:
- Transaction version (like now)
    - Version
    - Version group ID
- Transaction header
    - Expiry height etc
    - Likely need some kind of key-value map here to allow additional fields to be added, or maybe version the header to allow evolution?
- Transparent transaction value pool "traffic map"
    - Option 1: BundleVersionID -> (valueBalance, AssetId -> valueBalance)
        - Key: Bundle version ID
        - Value:
            - ZEC `valueBalance`
            - CompactSize len(generalizedValueBalances)
            - Zero or more generalized value balances
                - `AssetId` (not `AssetBase` because those are protocol-specific, and we want generalized value balances to be understandable independently of protocol changes)
                - `valueBalance`
    - Option 2: (BundleVersionID, Option[AssetId]) -> valueBalance
        - Key: Bundle version ID encoded as u8 || { Option[AssetId] }
        - Value: `valueBalance`
    - Option 3: BundleVersionID -> Option[AssetId] -> valueBalance
        - Key: Bundle version ID
        - Value:
            - Map containing one or more generalized value balances
                - { Option[AssetId] }
                - `valueBalance`
- Sequence of bundles (maybe with a length prefix?)
    - Bundle version ID
        - Flag bits, either in the version ID or next to it, that indicate how an opaquely-parsing wallet should interpret the bundle, e.g.:
            - A bit that says whether or not the bundle interacts with the transparent transaction value pool (which memo bundles would not have).
                - Counterpoint: The traffic map already specifies whether a given bundle *does* have an interaction with the transparent tx value pool for this tx. This is different from whether that kind of bundle *can* interact with the transparent tx value pool, but it the latter needed?
            - A bit that says whether the bundle has any other effect than what is specified in the traffic map.
                - Counterpoint: We should split apart effecting and authorizing data in the encoding, and then a bundle must be assumed effecting iff it has non-null effecting data.
    - CompactSize len(effectingData)
    - effectingData
    - CompactSize len(authorizingData)
    - authorizingData
        - effectingData and authorizingData would be opaque to the initial parser.
        - Parsers that support parsing (tx_version, bundle_version) know how to interpret its internals

Transaction Format
------------------

+-----------------------------+------------------------------+------------------------------------------------+---------------------------------------------------------------------+
| Bytes                       | Name                         | Data Type                                      | Description                                                         |
+=============================+==============================+================================================+=====================================================================+
| **Common Transaction Fields**                                                                                                                                                     |
+-----------------------------+------------------------------+------------------------------------------------+---------------------------------------------------------------------+
| 4                           |``header``                    |``uint32``                                      |Contains:                                                            |
|                             |                              |                                                |                                                                     |
|                             |                              |                                                |* ``fOverwintered`` flag (bit 31, always set)                        |
|                             |                              |                                                |* ``version`` (bits 30 .. 0) – transaction version.                  |
+-----------------------------+------------------------------+------------------------------------------------+---------------------------------------------------------------------+
| 4                           |``nVersionGroupId``           |``uint32``                                      |Version group ID (nonzero).                                          |
+-----------------------------+------------------------------+------------------------------------------------+---------------------------------------------------------------------+
| 4                           |``nConsensusBranchId``        |``uint32``                                      |Consensus branch ID (nonzero).                                       |
+-----------------------------+------------------------------+------------------------------------------------+---------------------------------------------------------------------+
| 4                           |``lock_time``                 |``uint32``                                      |Unix-epoch UTC time or block height, encoded as in Bitcoin.          |
+-----------------------------+------------------------------+------------------------------------------------+---------------------------------------------------------------------+
| 4                           |``nExpiryHeight``             |``uint32``                                      |A block height in the range {1 .. 499999999} after which             |
|                             |                              |                                                |the transaction will expire, or 0 to disable expiry. [#zip-0203]_    |
+-----------------------------+------------------------------+------------------------------------------------+---------------------------------------------------------------------+
| **Transparent transaction value pool balance map**                                                                                                                                |
+-----------------------------+------------------------------+------------------------------------------------+---------------------------------------------------------------------+
| varies                      |``nValuePoolDeltas``          |``compactSize``                                 |Number of entries in the ``mValuePoolDeltas`` map.                   |
+-----------------------------+------------------------------+------------------------------------------------+---------------------------------------------------------------------+
| varies                      |``mValuePoolDeltas``          |``ValuePoolDelta[nValuePoolDeltas]``            |A map describing the change to the transparent value pool produced by| 
|                             |                              |                                                |each bundle. Only bundles that produces changes to the transparent   |
|                             |                              |                                                |value balance will have corresponding entries in this map.           |
+-----------------------------+------------------------------+------------------------------------------------+---------------------------------------------------------------------+
| **Bundles**                                                                                                                                                                       |
+-----------------------------+------------------------------+------------------------------------------------+---------------------------------------------------------------------+
| varies                      |``nBundles``                  |``compactSize``                                 |Number of bundles in the transaction that have per-bundle data.      |
+-----------------------------+------------------------------+------------------------------------------------+---------------------------------------------------------------------+
| varies                      |``vBundles``                  |``BundleDescription[nBundles]``                 |A sequence of Bundle descriptions.                                   |
+-----------------------------+------------------------------+------------------------------------------------+---------------------------------------------------------------------+

* `vBundles` MUST NOT contain duplicate `BundleDescription.

ValuePoolDelta
--------------

+-----------------------------+------------------------------+------------------------------------------------+---------------------------------------------------------------------+
| Bytes                       | Name                         | Data Type                                      | Description                                                         |
+=============================+==============================+================================================+=====================================================================+
| 1                           |``bundleType``                |``uint8``                                       |A bundle type identifier.                                            |
+-----------------------------+------------------------------+------------------------------------------------+---------------------------------------------------------------------+
| 1                           |``assetClass``                |``uint8``                                       |An asset class identifier. 0 for the ZEC asset, nonzero for any      |
|                             |                              |                                                |other asset type.                                                    |
+-----------------------------+------------------------------+------------------------------------------------+---------------------------------------------------------------------+
| varies                      |``assetId``                   |``byte[varies]``                                |If `assetClass == 0`, the zero-length byte array, otherwise a byte   |
|                             |                              |                                                |containing the asset ID for the asset. The length of this array      |
|                             |                              |                                                |depends on the asset class; ordinarily it will be 32 bytes.          |
+-----------------------------+------------------------------+------------------------------------------------+---------------------------------------------------------------------+
| 8                           |``value``                     |``int64``                                       |The net change to the transparent value pool produced by the bundle  |
|                             |                              |                                                |corresponding to the bundle type identifier.                         |
+-----------------------------+------------------------------+------------------------------------------------+---------------------------------------------------------------------+


## Bundle version ID Registry

+------------------------------+----------------------+-------------------------------------------------------------+
| Can appear in value pool map | Can have bundle data | Bundle kind                                                 |
+==============================+======================+=============================================================+
|✅                            |❌                    | Transaction fee                                             |
+------------------------------+----------------------+-------------------------------------------------------------+
|✅                            |❌                    | ZIP 233 NSM field                                           |
+------------------------------+----------------------+-------------------------------------------------------------+
|✅                            |✅                    | Transparent                                                 |
+------------------------------+----------------------+-------------------------------------------------------------+
|✅                            |✅                    | Sapling-pre-ZIP 231 (if ZIP 231 activated after this ZIP)   |
+------------------------------+----------------------+-------------------------------------------------------------+
|✅                            |✅                    | Orchard-pre-ZIP 231                                         |
+------------------------------+----------------------+-------------------------------------------------------------+
|✅                            |✅                    | Sapling-post-ZIP 231 (if ZIP 231 activated after this ZIP)  |
+------------------------------+----------------------+-------------------------------------------------------------+
|✅                            |✅                    | Orchard-post-ZIP 231                                        |
+------------------------------+----------------------+-------------------------------------------------------------+
|✅                            |✅                    | OrchardZSA                                                  |
+------------------------------+----------------------+-------------------------------------------------------------+
|✅                            |✅                    | TZEs                                                        |
+------------------------------+----------------------+-------------------------------------------------------------+
|❌                            |✅                    | ZIP 231 Memos                                               |
+------------------------------+----------------------+-------------------------------------------------------------+
|✅                            |✅                    | ZSA Issuance                                                |
+------------------------------+----------------------+-------------------------------------------------------------+
|❌                            |✅                    | Key rotation                                                |
+------------------------------+----------------------+-------------------------------------------------------------+
|✅                            |✅                    | Lockbox disbursement / "Consensus accounts"                 |
|                              |                      | (for miner payouts, lockbox, etc)                           |
+------------------------------+----------------------+-------------------------------------------------------------+
|✅                            |✅                    | Pool that only has a long-term storage protocol (PQ, very   |
|                              |                      | simple thus insulated from counterfeiting fears, can be     |
|                              |                      | used for payments but higher latency for that purpose)      |
+------------------------------+----------------------+-------------------------------------------------------------+
|✅                            |✅                    | Tachyon                                                     |
+------------------------------+----------------------+-------------------------------------------------------------+
|✅                            |✅                    | Staking                                                     |
+------------------------------+----------------------+-------------------------------------------------------------+
|✅                            |✅                    | Unstaking (if it can't be combined with the Staking bundle) |
+------------------------------+----------------------+-------------------------------------------------------------+
|✅                            |✅                    | Post-quantum fast payment protocol                          |
+------------------------------+----------------------+-------------------------------------------------------------+

Rationale
=========

TODO: Document why we take the specific approach we do on what the format constrains vs what wallets are expected (required?) to notify users of (once we decide on the approach).


Deployment
==========


Reference implementation
========================


Open issues
===========

Design Considerations
=====================

It is okay that a wallet might not be able to see parts of the transaction that
depend on new features, as long as they do not create such parts themselves.

If a wallet needs to actively do something differently (for example,
advertizing addresses in a new format or creating an output with a TZE
precondition) in order to be affected by a new feature, then it is reasonably
safe for it to ignore the feature as long as it can still parse transactions
and, and create and sign transactions that don't make use of those features.

Wallets or consensus-dependent applications that send transactions might do
something wrong that compromises user funds or privacy if they do not take into
account consensus changes in an upgrade. In particular, consensus rules may
change in such a way that a wallet doing what it has done in the past causes
risk of loss of funds, and in those cases, major transaction version bumps will
still be required. An example of this was [ZIP
212](https://zips.z.cash/zip-0212). In that case the existing mechanisms failed
to prevent loss of funds because in practice, wallets updated the consensus
branch ID without updating note encryption. In this case we made the mistake of
requiring wallets to change their behaviour for an existing transaction
version. Except for certain cases involving severe security flaws, we can avoid
doing that again.

Loss of funds is unacceptable. Temporary inaccessibility of funds in certain
circumstances can be okay -- provided that this potential inaccessiblity and
the circumstances where it can occur is documented and an explicit design
decision.

References
==========

[^BCP14]: [Information on BCP 14 — "RFC 2119: Key words for use in RFCs to Indicate Requirement Levels" and "RFC 8174: Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"](https://www.rfc-editor.org/info/bcp14)

[^protocol]: [Zcash Protocol Specification, Version 2025.6.3 [NU6.1] or later](protocol/protocol.pdf)

[^protocol-blockchain]: [Zcash Protocol Specification, Version 2025.6.3 [NU6.1]. Section 3.3: The Block Chain](protocol/protocol.pdf#blockchain)

[^protocol]: [Zcash Protocol Specification, Version 2025.6.3 [NU6.1]. Section 3.12: Mainnet and Testnet](protocol/protocol.pdf#networks)





---

# Notes on consensus branch ID & transaction format updates

Wallets or consensus-dependent applications that send transactions, might do something wrong that compromises user funds or privacy if they do not take into account consensus changes in an upgrade.

In particular, consensus rules may change in such a way that a wallet doing what it has done in the past causes risk of loss of funds.

An example of this was [ZIP 212](https://zips.z.cash/zip-0212). In that case the existing mechanisms failed to prevent loss of funds because in practice, wallets updated the consensus branch ID without updating note encryption.

> We made the mistake of requiring wallets to change their behaviour for an existing transaction version. Except for certain cases involving severe security flaws, we can avoid doing that again.

For some new features, it might be possible for a wallet to continue functioning correctly without having to fully understand a transaction using that feature. For instance, if a wallet needs to actively do something differently (for example, advertizing addresses in a new format or creating an output with a TZE precondition) in order to be affected by a new feature, then it is reasonably safe for it to ignore the feature as long as it can still parse transactions and sign them.

For example, if TZEs were to be added, it might be possible for wallets to continue operating with transparent/Sapling/Orchard functionality, ignoring TZE parts. There is some precedent for this as many wallets didn't begin interacting with Orchard transaction parts until quite a while after Orchard activation.

It is okay that such a wallet might not be able to see funds that depend on new features, as long as they do not create such funds themselves.

Loss of funds is unacceptable. Temporary inaccessibility of funds in certain circumstances can be okay -- provided that this potential inaccessiblity and the circumstances where it can occur is documented and an explicit design decision.

## Strawman

Modify how we approach transaction format evolution, such that (after one more change to transaction encoding) it is possible for a wallet that has not adopted a parser for a given transaction format to continue to function after an *additive* change to the transaction format. Another way to state this is that we should make it possible to make "semver-compatible" transaction format changes.

- @str4d: We could use a TLV approach where each "bundle" has a value balance. The NSM burn amount field could be its own bundle, the explicit fee data could be its own bundle and the consensus rule could be that all value balances sum to zero. 
    - generically, you want a value balance vector, where you have zero or more value balances moving between bundles in other assets.

- @nuttycom: You could have pre-ZSA and post-ZSA Orchard bundles.

## Strawman II

Treat bundles as individually versioned.
- Each bundle is registered with an ID relative to a tx version group ID.
- The bundle ID encoding also has some flag bits indicating how it interacts with the tx as a whole.
- Transactions then have two "bundle maps":
    - The first encodes how value moves between the different bundles.
    - The second encodes data specific to a bundle (e.g. how value moves within a bundle)
    - Bundles that don't have any data would just appear in the first map, and bundles that don't produce or consume value would just appear in the second map.
- We can re-interpret various other facets of transactions as "bundles"
    - Explicit fees are a bundle that never produces value
    - NSM field similarly never produces value
    - ZSA burns would be split into "value balance out of Orchard pool" and "value balance being removed from ZSA issuance"
    - See also the conversation we had about refactoring coinbase transactions. TODO: Figure out how to integrate the two.
- Privacy effect is minimal
    - We already follow a bundle approach with a transparent transaction value pool, for the turnstiles. This leans into it, while preserving the bundle boundary within which we implement each privacy protocol.
    - Some combinations of bundles would be permitted by the tx format that were not previously permitted.
        - However, we can still restrict which combinations of bundles can be mined in the consensus rules.

Sketch of the format:
- Transaction version (like now)
    - Version
    - Version group ID
- Transaction header
    - Expiry height etc
    - Likely need some kind of key-value map here to allow additional fields to be added, or maybe version the header to allow evolution?
- Transparent transaction value pool "traffic map"
    - Key: Bundle version ID
    - Value:
        - ZEC `valueBalance`
        - CompactSize len(generalizedValueBalances)
        - Zero or more generalized value balances
            - `AssetId` (not `AssetBase` because those are protocol-specific, and we want generalized value balances to be understandable independently of protocol changes)
            - `valueBalance`
- Sequence of bundles (maybe with a length prefix?)
    - Bundle version ID
        - Flag bits, either in the version ID or next to it, that indicate how an opaquely-parsing wallet should interpret the bundle, e.g.:
            - A bit that says whether or not the bundle interacts with the transparent transaction value pool (which memo bundles would not have).
                - Counterpoint: The traffic map already specifies whether a given bundle *does* have an interaction with the transparent tx value pool for this tx. This is different from whether that kind of bundle *can* interact with the transparent tx value pool, but it the latter needed?
            - A bit that says whether the bundle has any other effect than what is specified in the traffic map.
                - Counterpoint: We should split apart effecting and authorizing data in the encoding, and then a bundle must be assumed effecting iff it has non-null effecting data.
    - CompactSize len(effectingData)
    - effectingData
    - CompactSize len(authorizingData)
    - authorizingData
        - effectingData and authorizingData would be opaque to the initial parser.
        - Parsers that support parsing (tx_version, bundle_version) know how to interpret its internals

Questions:
- Is it okay for fee calculations to be opaque to wallet parsers, as long as the fee amounts can be calculated in consensus?
    - Yes:
        - When receiving, all you care about is knowing the actual fee amount; you see that in the fee bundle's value balance.
        - When sending, you need to understand all bundles you are including, and then you can calculate the fee.
- Can wallets still compute the txid and wtxid of an arbitrary transaction?
    - Yes, provided that effecting and authorizing data is separated. Then they can hash the effecting data even without understanding it to compute the txid, and they can hash the authorizing data even without understanding it to compute the authorizing data commitment part of the wtxid [[ZIP 239]](https://zips.z.cash/zip-0239).
    - *However*, this reintroduces a more direct linkage between the [w]txid computation and the transaction encoding. It's arguably fine, and potentially simpler -- since the [w]txid computation need not change at all for most protocol changes.
    - If the hashing uses flat hashes over the effectingData and authorizingData of each bundle (which it has to because the internal structure is not known), then it might be more difficult to do Merkle proofs over subsets of the data within a bundle. We haven't used that so far; is it really needed?

