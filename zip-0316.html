<!DOCTYPE html>
<html>
<head>
    <title>ZIP 316: Unified Addresses and Unified Viewing Keys</title>
    <meta charset="utf-8" />
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js?config=TeX-AMS-MML_HTMLorMML"></script>
<meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="css/style.css"></head>
<body>
    <section>
        <pre>ZIP: 316
Title: Unified Addresses and Unified Viewing Keys
Owners: Daira Hopwood &lt;daira@electriccoin.co&gt;
        Nathan Wilcox &lt;nathan@electriccoin.co&gt;
        Taylor Hornby &lt;taylor@electriccoin.co&gt;
        Jack Grigg &lt;jack@electriccoin.co&gt;
        Sean Bowe &lt;sean@electriccoin.co&gt;
        Kris Nuttycombe &lt;kris@electriccoin.co&gt;
        Ying Tong Lai &lt;yingtong@electriccoin.co&gt;
Status: Proposed
Category: Standards / RPC / Wallet
Created: 2021-04-07
License: MIT
Discussions-To: &lt;<a href="https://github.com/zcash/zips/issues/482">https://github.com/zcash/zips/issues/482</a>&gt;</pre>
        <section id="terminology"><h2><span class="section-heading">Terminology</span><span class="section-anchor"> <a rel="bookmark" href="#terminology"><img width="24" height="24" src="assets/images/section-anchor.png" alt=""></a></span></h2>
            <p>The key words "MUST", "MUST NOT", and "SHOULD" in this document are to be interpreted as described in RFC 2119. <a id="id1" class="footnote_reference" href="#rfc2119">1</a></p>
            <p>The terms below are to be interpreted as follows:</p>
            <dl>
                <dt>Recipient</dt>
                <dd>A wallet or other software that can receive transfers of assets (such as ZEC) or in the future potentially other transaction-based state changes.</dd>
                <dt>Producer</dt>
                <dd>A wallet or other software that can create an Address (normally also a Recipient).</dd>
                <dt>Consumer</dt>
                <dd>A wallet or other software that can make use of an Address that it is given.</dd>
                <dt>Sender</dt>
                <dd>A wallet or other software that can send transfers of assets, or other consensus state side-effects defined in future. Senders are a subset of Consumers.</dd>
                <dt>Receiver</dt>
                <dd>The necessary information to transfer an asset to a Recipient that generated that Receiver using a specific Transfer Protocol. Each Receiver is associated unambiguously with a specific Receiver Type, identified by an integer Typecode.</dd>
                <dt>Receiver Encoding</dt>
                <dd>An encoding of a Receiver as a byte sequence.</dd>
                <dt>Legacy Address (or LA)</dt>
                <dd>A Transparent, Sprout, or Sapling Address.</dd>
                <dt>Unified Address (or UA)</dt>
                <dd>A Unified Address combines multiple Receivers.</dd>
                <dt>Unified Full Viewing Key (or UFVK)</dt>
                <dd>A Unified Full Viewing Key combines multiple Full Viewing Keys.</dd>
                <dt>Unified Incoming Viewing Key (or UIVK)</dt>
                <dd>A Unified Incoming Viewing Key combines multiple Incoming Viewing Keys.</dd>
                <dt>Address</dt>
                <dd>Either a Legacy Address or a Unified Address.</dd>
                <dt>Transfer Protocol</dt>
                <dd>A specification of how a Sender can transfer assets to a Recipient. For example, the Transfer Protocol for a Sapling Receiver is the subset of the Zcash protocol required to successfully transfer ZEC using Sapling Spend/Output Transfers as specified in the Zcash Protocol Specification. (A single Zcash transaction can contain transfers of multiple Transfer Protocols. For example a t→z transaction that shields to the Sapling pool requires both Transparent and Sapling Transfer Protocols.)</dd>
                <dt>Address Encoding</dt>
                <dd>The externally visible encoding of an Address (e.g. as a string of characters or a QR code).</dd>
            </dl>
        </section>
        <section id="abstract"><h2><span class="section-heading">Abstract</span><span class="section-anchor"> <a rel="bookmark" href="#abstract"><img width="24" height="24" src="assets/images/section-anchor.png" alt=""></a></span></h2>
            <p>This proposal defines Unified Addresses, which bundle together Zcash Addresses of different types in a way that can be presented as a single Address Encoding. It also defines Unified Viewing Keys, which perform a similar function for Zcash viewing keys.</p>
        </section>
        <section id="motivation"><h2><span class="section-heading">Motivation</span><span class="section-anchor"> <a rel="bookmark" href="#motivation"><img width="24" height="24" src="assets/images/section-anchor.png" alt=""></a></span></h2>
            <p>Up to and including the Canopy network upgrade, Zcash supported the following Payment Address types:</p>
            <ul>
                <li>Transparent Addresses (P2PKH and P2SH)</li>
                <li>Sprout Addresses</li>
                <li>Sapling Addresses</li>
            </ul>
            <p>Each of these has its own Address Encodings, as a string and as a QR code. (Since the QR code is derivable from the string encoding, for many purposes it suffices to consider the string encoding.)</p>
            <p>The Orchard proposal <a id="id2" class="footnote_reference" href="#zip-0224">6</a> adds a new Address type, Orchard Addresses.</p>
            <p>The difficulty with defining new Address Encodings for each Address type, is that end-users are forced to be aware of the various types, and in particular which types are supported by a given Consumer or Recipient. In order to make sure that transfers are completed successfully, users may be forced to explicitly generate Addresses of different types and re-distribute encodings of them, which adds significant friction and cognitive overhead to understanding and using Zcash.</p>
            <p>The goals for a Unified Address standard are as follows:</p>
            <ul>
                <li>Simplify coordination between Recipients and Consumers by removing complexity from negotiating Address types.</li>
                <li>Provide a “bridging mechanism” to allow shielded wallets to successfully interact with conformant Transparent-Only wallets.</li>
                <li>Allow older conformant wallets to interact seamlessly with newer wallets.</li>
                <li>Enable users of newer wallets to upgrade to newer transaction technologies and/or pools while maintaining seamless interactions with counterparties using older wallets.</li>
                <li>Facilitate wallets to assume more sophisticated responsibilities for shielding and/or migrating user funds.</li>
                <li>Allow wallets to potentially develop new transfer mechanisms without underlying protocol changes.</li>
                <li>Support abstractions corresponding to a Unified Address that provide the functionality of Full Viewing Keys and Incoming Viewing Keys.</li>
                <li>Provide forward compatibility that is standard for all wallets across a range of potential future features. Some examples might include Layer 2 features, cross-chain interoperability and bridging, and decentralized exchange.</li>
                <li>The standard should work well for Zcash today and upcoming potential upgrades, and also anticipate even broader use cases down the road such as cross-chain functionality.</li>
            </ul>
        </section>
        <section id="requirements"><h2><span class="section-heading">Requirements</span><span class="section-anchor"> <a rel="bookmark" href="#requirements"><img width="24" height="24" src="assets/images/section-anchor.png" alt=""></a></span></h2>
            <section id="overview"><h3><span class="section-heading">Overview</span><span class="section-anchor"> <a rel="bookmark" href="#overview"><img width="24" height="24" src="assets/images/section-anchor.png" alt=""></a></span></h3>
                <p>Unified Addresses specify multiple methods for payment to a Recipient's Wallet. The Sender's Wallet can then non-interactively select the method of payment.</p>
                <p>Importantly, any wallet can support Unified Addresses, even when that wallet only supports a subset of payment methods for receiving and/or sending.</p>
                <p>Despite having some similar characteristics, the Unified Address standard is orthogonal to Payment Request URIs <a id="id3" class="footnote_reference" href="#zip-0321">7</a> and similar schemes, and the Unified Address format is likely to be incorporated into such schemes as a new Address type.</p>
            </section>
            <section id="concepts"><h3><span class="section-heading">Concepts</span><span class="section-anchor"> <a rel="bookmark" href="#concepts"><img width="24" height="24" src="assets/images/section-anchor.png" alt=""></a></span></h3>
                <p>Wallets follow a model <em>Interaction Flow</em> as follows:</p>
                <ol type="1">
                    <li>A Producer <em>generates</em> an Address.</li>
                    <li>The Producer <em>encodes</em> the Address.</li>
                    <li>The Producer wallet or human user <em>distributes</em> this Address Encoding, This ZIP leaves distribution mechanisms out of scope.</li>
                    <li>A Consumer wallet or user <em>imports</em> the Address Encoding through any of a variety of mechanisms (QR Code scanning, Payment URIs, cut-and-paste, or “in-band” protocols like <code>Reply-To</code> memos).</li>
                    <li>A Consumer wallet <em>decodes</em> the Address Encoding and performs validity checks.</li>
                    <li>(Perhaps later in time) if the Consumer wallet is a Sender, it can execute a transfer of ZEC (or other assets or protocol state changes) to the Address.</li>
                </ol>
                <p>Encodings of the same Address may be distributed zero or more times through different means. Zero or more Consumers may import Addresses. Zero or more of those (that are Senders) may execute a Transfer. A single Sender may execute multiple Transfers over time from a single import.</p>
                <p>Steps 1 to 5 inclusive also apply to Interaction Flows for Unified Full Viewing Keys and Unified Incoming Viewing Keys.</p>
            </section>
            <section id="addresses"><h3><span class="section-heading">Addresses</span><span class="section-anchor"> <a rel="bookmark" href="#addresses"><img width="24" height="24" src="assets/images/section-anchor.png" alt=""></a></span></h3>
                <p>A Unified Address (or UA for short) combines one or more Receivers.</p>
                <p>When new Transport Protocols are introduced to the Zcash protocol after Unified Addresses are standardized, those should introduce new Receiver Types but <em>not</em> different Address types outside of the UA standard. There needs to be a compelling reason to deviate from the standard, since the benefits of UA come precisely from their applicability across all new protocol upgrades.</p>
            </section>
            <section id="receivers"><h3><span class="section-heading">Receivers</span><span class="section-anchor"> <a rel="bookmark" href="#receivers"><img width="24" height="24" src="assets/images/section-anchor.png" alt=""></a></span></h3>
                <p>Every Wallet must properly <em>parse</em> a Unified Address containing unrecognized Receiver Types; and similarly for Unified Full Viewing Keys and Unified Incoming Viewing Keys.</p>
                <p>A Wallet may process unrecognized Receiver Types by indicating to the user their presence or similar information for usability or diagnostic purposes.</p>
            </section>
            <section id="transport-encoding"><h3><span class="section-heading">Transport Encoding</span><span class="section-anchor"> <a rel="bookmark" href="#transport-encoding"><img width="24" height="24" src="assets/images/section-anchor.png" alt=""></a></span></h3>
                <p>The string encoding is “opaque” to human readers: it does <em>not</em> allow visual identification of which Receivers or Receiver Types are present.</p>
                <p>The string encoding is resilient against typos, transcription errors, cut-and-paste errors, unanticipated truncation, or other anticipated UX hazards.</p>
                <p>There is a well-defined encoding of a Unified Address (or UFVK or UIVK) as a QR Code, which produces QR codes that are reasonably compact and robust.</p>
                <p>There is a well-defined transformation between the QR Code and string encodings in either direction.</p>
                <p>The string encoding fits into ZIP-321 Payment URIs <a id="id4" class="footnote_reference" href="#zip-0321">7</a> and general URIs without introducing parse ambiguities.</p>
                <p>The encoding must support sufficiently many Recipient Types to allow for reasonable future expansion.</p>
                <p>The encoding must allow all wallets to safely and correctly parse out unrecognized Receiver Types well enough to ignore them.</p>
            </section>
            <section id="transfers"><h3><span class="section-heading">Transfers</span><span class="section-anchor"> <a rel="bookmark" href="#transfers"><img width="24" height="24" src="assets/images/section-anchor.png" alt=""></a></span></h3>
                <p>When executing a Transfer the Sender selects a Receiver via a Selection process.</p>
                <p>Given a valid UA, Selection must treat any unrecognized Receiver as though it were absent.</p>
                <ul>
                    <li>This property is crucial for forward compatibility to ensure users who upgrade to newer protocols / UAs don't lose the ability to smoothly interact with older wallets.</li>
                    <li>This property is crucial for allowing Transparent-Only UA-Conformant wallets to interact with newer shielded wallets, removing a disincentive for adopting newer shielded wallets.</li>
                    <li>This property also allows Transparent-Only wallets to upgrade to shielded support without re-acquiring counterparty UAs. If they are re-acquired, the user flow and usability will be minimally disrupted.</li>
                </ul>
            </section>
            <section id="viewing-keys"><h3><span class="section-heading">Viewing Keys</span><span class="section-anchor"> <a rel="bookmark" href="#viewing-keys"><img width="24" height="24" src="assets/images/section-anchor.png" alt=""></a></span></h3>
                <p>A Unified Full Viewing Key (resp. Unified Incoming Viewing Key) can be used in a similar way to a Full Viewing Key (resp. Incoming Viewing Key) as described in the Zcash Protocol Specification <a id="id5" class="footnote_reference" href="#protocol-nu5">2</a>.</p>
                <p>Transparent Addresses do not have separate corresponding viewing keys, but the address itself can effectively be used as a viewing key. Therefore, a UFVK or UIVK should be able to include a Transparent Address.</p>
                <p>A wallet should support deriving a Unified Address from a UFVK, by deriving a Receiver from each Full Viewing Key in the UFVK. Any Transparent Address in the UFVK is left as-is.</p>
                <p>It is not possible to derive a Unified Address from a Unified Incoming Viewing Key.</p>
            </section>
            <section id="open-issues-and-known-concerns"><h3><span class="section-heading">Open Issues and Known Concerns</span><span class="section-anchor"> <a rel="bookmark" href="#open-issues-and-known-concerns"><img width="24" height="24" src="assets/images/section-anchor.png" alt=""></a></span></h3>
                <p>TODO: We have a few of these that will be added in future edits. This is especially true of privacy impacts of transparent or cross-pool transactions and the associated UX issues.</p>
            </section>
        </section>
        <section id="specification"><h2><span class="section-heading">Specification</span><span class="section-anchor"> <a rel="bookmark" href="#specification"><img width="24" height="24" src="assets/images/section-anchor.png" alt=""></a></span></h2>
            <section id="encoding-of-unified-addresses"><h3><span class="section-heading">Encoding of Unified Addresses</span><span class="section-anchor"> <a rel="bookmark" href="#encoding-of-unified-addresses"><img width="24" height="24" src="assets/images/section-anchor.png" alt=""></a></span></h3>
                <p>Rather than defining a Bech32 string encoding of Orchard Shielded Payment Addresses, we instead define a Unified Address format that is able to encode a set of Receivers of different types. This enables the Consumer of a Unified Address to choose the Receiver of the best type it supports, providing a better user experience as new Receiver Types are added in the future.</p>
                <p>Assume that we are given a set of one or more Receiver Encodings for distinct types. That is, the set may optionally contain one Receiver of each of the Receiver Types in the following fixed Priority List:</p>
                <ul>
                    <li>Typecode
                        <span class="math">\(\mathtt{0x03}\)</span>
                     — an Orchard raw address as defined in <a id="id6" class="footnote_reference" href="#protocol-orchardpaymentaddrencoding">4</a>;</li>
                    <li>Typecode
                        <span class="math">\(\mathtt{0x02}\)</span>
                     — a Sapling raw address as defined in <a id="id7" class="footnote_reference" href="#protocol-saplingpaymentaddrencoding">3</a>;</li>
                    <li>Typecode
                        <span class="math">\(\mathtt{0x01}\)</span>
                     — a Transparent P2SH address, <em>or</em> Typecode
                        <span class="math">\(\mathtt{0x00}\)</span>
                     — a Transparent P2PKH address.</li>
                </ul>
                <p>We say that a Receiver Type is “preferred” over another when it appears earlier in this Priority List.</p>
                <p>The Sender of a payment to a Unified Address MUST use the Receiver of the most preferred Receiver Type that it supports from the set.</p>
                <p>For example, consider a wallet that supports sending funds to Orchard Receivers, and does not support sending to any Receiver Type that is preferred over Orchard. If that wallet is given a UA that includes an Orchard Receiver and possibly other Receivers, it MUST send to the Orchard Receiver.</p>
                <p>The raw encoding of a Unified Address is a concatenation of
                    <span class="math">\((\mathtt{typecode}, \mathtt{length}, \mathtt{addr})\)</span>
                 encodings of the consituent Receivers:</p>
                <ul>
                    <li>
                        <span class="math">\(\mathtt{typecode} : \mathtt{byte}\)</span>
                     — the Typecode from the above Priority List;</li>
                    <li>
                        <span class="math">\(\mathtt{length} : \mathtt{byte}\)</span>
                     — the length in bytes of
                        <span class="math">\(\mathtt{addr}\)</span>
                    ;</li>
                    <li>
                        <span class="math">\(\mathtt{addr} : \mathtt{byte[length]}\)</span>
                     — the Receiver Encoding.</li>
                </ul>
                <p>A Receiver Encoding is the raw encoding of a Shielded Payment Address, or the
                    <span class="math">\(160\)</span>
                -bit script hash of a P2SH address <a id="id8" class="footnote_reference" href="#p2sh">10</a>, or the
                    <span class="math">\(160\)</span>
                -bit validating key hash of a P2PKH address <a id="id9" class="footnote_reference" href="#p2pkh">9</a>.</p>
                <p>Let <code>padding</code> be the Human-Readable Part of the Unified Address in US-ASCII, padded to 16 bytes with zero bytes. We append <code>padding</code> to the concatenated encodings, and then apply the
                    <span class="math">\(\mathsf{F4Jumble}\)</span>
                 algorithm as described in <a href="#address-hardening">Address Hardening</a>. The output is then encoded with Bech32m <a id="id10" class="footnote_reference" href="#bip-0350">8</a>, ignoring any length restrictions. This is chosen over Bech32 in order to better handle variable-length inputs.</p>
                <p>To decode a Unified Address Encoding, a Consumer MUST use the following procedure:</p>
                <ul>
                    <li>Decode using Bech32m, rejecting any address with an incorrect checksum.</li>
                    <li>Apply
                        <span class="math">\(\mathsf{F4Jumble}^{-1}\)</span>
                     (this can also reject if the input is not in the correct range of lengths).</li>
                    <li>Let <code>padding</code> be the Human-Readable Part, padded to 16 bytes as for encoding. If the result ends in <code>padding</code>, remove these 16 bytes; otherwise reject.</li>
                    <li>Parse the result as a raw encoding as described above, rejecting the entire Unified Address if it does not parse correctly.</li>
                </ul>
                <p>For Unified Addresses on Mainnet, the Human-Readable Part (as defined in <a id="id11" class="footnote_reference" href="#bip-0350">8</a>) is “<code>u</code>”. For Unified Addresses on Testnet, the Human-Readable Part is “<code>utest</code>”.</p>
                <p>A wallet MAY allow its user(s) to configure which Receiver Types it can send to. It MUST NOT allow the user(s) to change the order of the Priority List used to choose the Receiver Type.</p>
            </section>
            <section id="encoding-of-unified-full-incoming-viewing-keys"><h3><span class="section-heading">Encoding of Unified Full/Incoming Viewing Keys</span><span class="section-anchor"> <a rel="bookmark" href="#encoding-of-unified-full-incoming-viewing-keys"><img width="24" height="24" src="assets/images/section-anchor.png" alt=""></a></span></h3>
                <p>Unified Full or Incoming Viewing Keys are encoded and decoded analogously to Unified Addresses. A Consumer MUST use the decoding procedure from the previous section. The same Priority List and the same Typecodes are used. The Priority List only applies to situations in which a Consumer needs to choose a particular Receiver.</p>
                <p>For Shielded Addresses, the encoding used in place of the
                    <span class="math">\(\mathtt{addr}\)</span>
                 field is the raw encoding of the Full Viewing Key or Incoming Viewing Key.</p>
                <p>Transparent Addresses do not have separate corresponding viewing keys, but the address itself can effectively be used as a viewing key. Therefore, a UFVK or UIVK MAY include a Transparent Address, which is encoded using the same Typecode and Receiver Encoding as in a Unified Address.</p>
                <p>The Human-Readable Parts (as defined in [#bip-0350]) of Unified Viewing Keys are defined as follows:</p>
                <ul>
                    <li>“<code>uivk</code>” for Unified Incoming Viewing Keys on Mainnet;</li>
                    <li>“<code>uivktest</code>” for Unified Incoming Viewing Keys on Testnet;</li>
                    <li>“<code>uview</code>” for Unified Full Viewing Keys on Mainnet;</li>
                    <li>“<code>uviewtest</code>” for Unified Full Viewing Keys on Testnet.</li>
                </ul>
            </section>
            <section id="requirements-for-both-unified-addresses-and-unified-viewing-keys"><h3><span class="section-heading">Requirements for both Unified Addresses and Unified Viewing Keys</span><span class="section-anchor"> <a rel="bookmark" href="#requirements-for-both-unified-addresses-and-unified-viewing-keys"><img width="24" height="24" src="assets/images/section-anchor.png" alt=""></a></span></h3>
                <ul>
                    <li>A Unified Address or Unified Viewing Key MUST NOT contain only transparent P2SH or P2PKH addresses (Typecodes
                        <span class="math">\(\mathtt{0x00}\)</span>
                     and
                        <span class="math">\(\mathtt{0x01}\)</span>
                    ). The rationale is that the existing P2SH and P2PKH transparent-only address formats suffice for this purpose and are already supported by the existing ecosystem.</li>
                    <li>The
                        <span class="math">\(\mathtt{length}\)</span>
                     field is always encoded as a single byte, <em>not</em> as a
                        <span class="math">\(\mathtt{compactSize}\)</span>
                    .</li>
                    <li>For Transparent Addresses, the Receiver Encoding does not include the first two bytes of a raw encoding.</li>
                    <li>There is intentionally no Typecode defined for a Sprout Shielded Payment Address or Sprout Incoming Viewing Key. Since it is no longer possible (since activation of ZIP 211 in the Canopy network upgrade <a id="id12" class="footnote_reference" href="#zip-0211">5</a>) to send funds into the Sprout chain value pool, this would not be generally useful.</li>
                    <li>Consumers MUST ignore constituent Addresses/Viewing Keys with Typecodes they do not recognize.</li>
                    <li>Consumers MUST reject Unified Addresses/Viewing Keys in which the same Typecode appears more than once, or that include both P2SH and P2PKH Transparent Addresses, or that contain only a Transparent Address.</li>
                    <li>Consumers MUST reject Unified Addresses/Viewing Keys in which <em>any</em> constituent address does not meet the validation requirements of its Receiver Encoding, as specified in the Zcash Protocol Specification <a id="id13" class="footnote_reference" href="#protocol-nu5">2</a>.</li>
                    <li>Producers SHOULD order the constituent Addresses/Viewing Keys in the same order as in the Priority List above. However, Consumers MUST NOT assume this ordering, and it does not affect which Address should be used by a Sender.</li>
                    <li>There MUST NOT be additional bytes at the end of the raw encoding that cannot be interpreted as specified above.</li>
                </ul>
            </section>
            <section id="address-hardening"><h3><span class="section-heading">Address hardening</span><span class="section-anchor"> <a rel="bookmark" href="#address-hardening"><img width="24" height="24" src="assets/images/section-anchor.png" alt=""></a></span></h3>
                <p>Security goal (<strong>near second preimage resistance</strong>):</p>
                <ul>
                    <li>An adversary is given
                        <span class="math">\(q\)</span>
                     Unified Addresses, generated honestly.</li>
                    <li>The attack goal is to produce a “partially colliding” valid Unified Address that:
                        <ol suffix=")" type="a">
                            <li>has a string encoding matching that of <em>one of</em> the input Addresses on some subset of characters (for concreteness, consider the first
                                <span class="math">\(n\)</span>
                             and last
                                <span class="math">\(m\)</span>
                             characters, up to some bound on
                                <span class="math">\(n+m\)</span>
                            );</li>
                            <li>is controlled by the adversary (for concreteness, the adversary knows <em>at least one</em> of the private keys of the constituent Addresses).</li>
                        </ol>
                    </li>
                </ul>
                <p>Security goal (<strong>nonmalleability</strong>):</p>
                <ul>
                    <li>In this variant, part b) above is replaced by the meaning of the new Address being “usefully” different than the Address it is based on, even though the adversary does not know any of the private keys. For example, if it were possible to delete a shielded constituent Address from a UA leaving only a Transparent Address, that would be a significant malleability attack.</li>
                </ul>
                <section id="discussion"><h4><span class="section-heading">Discussion</span><span class="section-anchor"> <a rel="bookmark" href="#discussion"><img width="24" height="24" src="assets/images/section-anchor.png" alt=""></a></span></h4>
                    <p>There is a generic brute force attack against near second preimage resistance. The adversary generates UAs at random with known keys, until one has an encoding that partially collides with one of the
                        <span class="math">\(q\)</span>
                     target Addresses. It may be possible to improve on this attack by making use of properties of checksums, etc.</p>
                    <p>The generic attack puts an upper bound on the achievable security: if it takes work
                        <span class="math">\(w\)</span>
                     to produce and verify a UA, and the size of the character set is
                        <span class="math">\(c\)</span>
                    , then the generic attack costs
                        <span class="math">\(\sim \frac{w \cdot
c^{n+m}}{q}\)</span>
                    .</p>
                    <p>There is also a generic brute force attack against nonmalleability. The adversary modifies the target Address slightly and computes the corresponding decoding, then repeats until the decoding is valid and also useful to the adversary (e.g. it would lead to the Sender using a Transparent Address). With
                        <span class="math">\(w\)</span>
                     defined as above, the cost is
                        <span class="math">\(w/p\)</span>
                     where
                        <span class="math">\(p\)</span>
                     is the probability that a random decoding is of the required form.</p>
                </section>
                <section id="solution"><h4><span class="section-heading">Solution</span><span class="section-anchor"> <a rel="bookmark" href="#solution"><img width="24" height="24" src="assets/images/section-anchor.png" alt=""></a></span></h4>
                    <p>We use an unkeyed 4-round Feistel construction to approximate a random permutation. (As explained below, 3 rounds would not be sufficient.)</p>
                    <p>Let
                        <span class="math">\(H_i\)</span>
                     be a hash personalized by
                        <span class="math">\(i\)</span>
                    , with maximum output length
                        <span class="math">\(\ell_H\)</span>
                     bytes. Let
                        <span class="math">\(G_i\)</span>
                     be a XOF (a hash function with extendable output length) based on
                        <span class="math">\(H\)</span>
                    , personalized by
                        <span class="math">\(i\)</span>
                    .</p>
                    <p>Given input
                        <span class="math">\(M\)</span>
                     of length
                        <span class="math">\(\ell_M\)</span>
                     bytes such that
                        <span class="math">\(48 \leq \ell_M \leq 16448\)</span>
                    , define
                        <span class="math">\(\mathsf{F4Jumble}(M)\)</span>
                     by:</p>
                    <ul>
                        <li>let
                            <span class="math">\(\ell_L = \mathsf{min}(\ell_H, \mathsf{floor}(\ell_M/2))\)</span>
                        </li>
                        <li>let
                            <span class="math">\(\ell_R = \ell_M - \ell_L\)</span>
                        </li>
                        <li>split
                            <span class="math">\(M\)</span>
                         into
                            <span class="math">\(a\)</span>
                         of length
                            <span class="math">\(\ell_L\)</span>
                         bytes and
                            <span class="math">\(b\)</span>
                         of length
                            <span class="math">\(\ell_R\)</span>
                         bytes</li>
                        <li>let
                            <span class="math">\(x = b \oplus G_0(a)\)</span>
                        </li>
                        <li>let
                            <span class="math">\(y = a \oplus H_0(x)\)</span>
                        </li>
                        <li>let
                            <span class="math">\(d = x \oplus G_1(y)\)</span>
                        </li>
                        <li>let
                            <span class="math">\(c = y \oplus H_1(d)\)</span>
                        </li>
                        <li>return
                            <span class="math">\(c \,||\, d\)</span>
                        .</li>
                    </ul>
                    <p>The inverse function
                        <span class="math">\(\mathsf{F4Jumble}^{-1}\)</span>
                     is obtained in the usual way for a Feistel construction, by observing that
                        <span class="math">\(r = p \oplus q\)</span>
                     implies
                        <span class="math">\(p = r \oplus q\)</span>
                    .</p>
                    <p>The first argument to BLAKE2b below is the personalization.</p>
                    <p>We instantiate
                        <span class="math">\(H_i(u)\)</span>
                     by
                        <span class="math">\(\mathsf{BLAKE2b‐}(8\ell_L)(\texttt{“UA_F4Jumble_H_”} \,||\,\)</span>
                        <span class="math">\([i, 0], u)\)</span>
                    .</p>
                    <p>We instantiate
                        <span class="math">\(G_i(u)\)</span>
                     as the first
                        <span class="math">\(\ell_R\)</span>
                     bytes of the concatenation of
                        <span class="math">\([\mathsf{BLAKE2b‐}512(\texttt{“UA_F4Jumble_G_”} \,||\,\)</span>
                        <span class="math">\([i, j], u) \text{ for } j \text{ from } 0 \text{ up to}\)</span>
                        <span class="math">\(\mathsf{ceiling}(\ell_R/\ell_H)-1]\)</span>
                    .</p>
                    <figure class="align-center" align="center">
                        <img width="372px" src="zip-0316-f4.png" />
                        <figcaption>Diagram of 4-round unkeyed Feistel construction</figcaption>
                    </figure>
                    <p>(In practice the lengths
                        <span class="math">\(\ell_L\)</span>
                     and
                        <span class="math">\(\ell_R\)</span>
                     will be roughly the same until
                        <span class="math">\(\ell_M\)</span>
                     is larger than
                        <span class="math">\(128\)</span>
                     bytes.)</p>
                </section>
                <section id="usage-for-unified-addresses-ufvks-and-uivks"><h4><span class="section-heading">Usage for Unified Addresses, UFVKs, and UIVKs</span><span class="section-anchor"> <a rel="bookmark" href="#usage-for-unified-addresses-ufvks-and-uivks"><img width="24" height="24" src="assets/images/section-anchor.png" alt=""></a></span></h4>
                    <p>In order to prevent the generic attack against nonmalleability, there needs to be some redundancy in the encoding. Therefore, the Producer of a Unified Address, UFVK, or UIVK appends the HRP, padded to 16 bytes with zero bytes, to the raw encoding, then applies
                        <span class="math">\(\mathsf{F4Jumble}\)</span>
                     before encoding the result with Bech32m.</p>
                    <p>The Consumer rejects any Bech32m-decoded byte sequence that is less than 48 bytes or greater than 16448 bytes; otherwise it applies
                        <span class="math">\(\mathsf{F4Jumble}^{-1}\)</span>
                    . It rejects any result that does not end in the expected padding, before stripping these 16 bytes and parsing the result.</p>
                    <p>(48 bytes is the minimum size of a valid UA, UFVK, or UIVK raw encoding plus 16 zero bytes, corresponding to a single Sapling Incoming Viewing Key. 16448 bytes is the largest input/output size supported by
                        <span class="math">\(\mathsf{F4Jumble}\)</span>
                    .)</p>
                </section>
                <section id="heuristic-analysis"><h4><span class="section-heading">Heuristic analysis</span><span class="section-anchor"> <a rel="bookmark" href="#heuristic-analysis"><img width="24" height="24" src="assets/images/section-anchor.png" alt=""></a></span></h4>
                    <p>A 3-round unkeyed Feistel, as shown, is not sufficient:</p>
                    <figure class="align-center" align="center">
                        <img width="372px" src="zip-0316-f3.png" />
                        <figcaption>Diagram of 3-round unkeyed Feistel construction</figcaption>
                    </figure>
                    <p>Suppose that an adversary has a target input/output pair
                        <span class="math">\((a \,||\, b, c \,||\, d)\)</span>
                    , and that the input to
                        <span class="math">\(H_0\)</span>
                     is
                        <span class="math">\(x\)</span>
                    . By fixing
                        <span class="math">\(x\)</span>
                    , we can obtain another pair
                        <span class="math">\(((a \oplus t) \,||\, b', (c \oplus t) \,||\, d')\)</span>
                     such that
                        <span class="math">\(a \oplus t\)</span>
                     is close to
                        <span class="math">\(a\)</span>
                     and
                        <span class="math">\(c \oplus t\)</span>
                     is close to
                        <span class="math">\(c\)</span>
                    . (
                        <span class="math">\(b'\)</span>
                     and
                        <span class="math">\(d'\)</span>
                     will not be close to
                        <span class="math">\(b\)</span>
                     and
                        <span class="math">\(d\)</span>
                    , but that isn't necessarily required for a valid attack.)</p>
                    <p>A 4-round Feistel thwarts this and similar attacks. Defining
                        <span class="math">\(x\)</span>
                     and
                        <span class="math">\(y\)</span>
                     as the intermediate values in the first diagram above:</p>
                    <ul>
                        <li>if
                            <span class="math">\((x', y')\)</span>
                         are fixed to the same values as
                            <span class="math">\((x, y)\)</span>
                        , then
                            <span class="math">\((a', b', c', d') = (a, b, c, d)\)</span>
                        ;</li>
                        <li>if
                            <span class="math">\(x' = x\)</span>
                         but
                            <span class="math">\(y' \neq y\)</span>
                        , then the adversary is able to introduce a controlled
                            <span class="math">\(\oplus\)</span>
                        -difference
                            <span class="math">\(a \oplus a' = y \oplus y'\)</span>
                        , but the other three pieces
                            <span class="math">\((b, c, d)\)</span>
                         are all randomized, which is sufficient;</li>
                        <li>if
                            <span class="math">\(y' = y\)</span>
                         but
                            <span class="math">\(x' \neq x\)</span>
                        , then the adversary is able to introduce a controlled
                            <span class="math">\(\oplus\)</span>
                        -difference
                            <span class="math">\(d \oplus d' = x \oplus x'\)</span>
                        , but the other three pieces
                            <span class="math">\((a, b, c)\)</span>
                         are all randomized, which is sufficient;</li>
                        <li>if
                            <span class="math">\(x' \neq x\)</span>
                         and
                            <span class="math">\(y' \neq y\)</span>
                        , all four pieces are randomized.</li>
                    </ul>
                    <p>Note that the size of each piece is at least 24 bytes.</p>
                    <p>It would be possible to make an attack more expensive by making the work done by a Producer more expensive. (This wouldn't necessarily have to increase the work done by the Consumer.) However, given that Unified Addresses may need to be produced on constrained computing platforms, this was not considered to be beneficial overall.</p>
                    <p>The padding contains the HRP so that the HRP has the same protection against malleation as the rest of the address. This may help against cross-network attacks, or attacks that confuse addresses with viewing keys.</p>
                </section>
                <section id="efficiency"><h4><span class="section-heading">Efficiency</span><span class="section-anchor"> <a rel="bookmark" href="#efficiency"><img width="24" height="24" src="assets/images/section-anchor.png" alt=""></a></span></h4>
                    <p>The cost is dominated by 4 BLAKE2b compressions for
                        <span class="math">\(\ell_M \leq 128\)</span>
                     bytes. A UA containing a Transparent Address, a Sapling Address, and an Orchard Address, would have
                        <span class="math">\(\ell_M = 128\)</span>
                     bytes. The restriction to a single Address with a given Typecode (and at most one Transparent Address) means that this is also the maximum length as of NU5 activation.</p>
                    <p>For longer UAs (when other Typecodes are added), the cost increases to 6 BLAKE2b compressions for
                        <span class="math">\(128 &lt; \ell_M \leq 192\)</span>
                    , and 10 BLAKE2b compressions for
                        <span class="math">\(192 &lt; \ell_M \leq 256\)</span>
                    , for example. The maximum cost for which the algorithm is defined would be 768 BLAKE2b compressions at
                        <span class="math">\(\ell_M = 16448\)</span>
                     bytes. We will almost certainly never add enough Typecodes to reach that, and we might want to define a smaller limit.</p>
                    <p>The memory usage, for a memory-optimized implementation, is roughly
                        <span class="math">\(\ell_M\)</span>
                     bytes plus the size of a BLAKE2b hash state.</p>
                </section>
                <section id="dependencies"><h4><span class="section-heading">Dependencies</span><span class="section-anchor"> <a rel="bookmark" href="#dependencies"><img width="24" height="24" src="assets/images/section-anchor.png" alt=""></a></span></h4>
                    <p>BLAKE2b, with personalization and variable output length, is the only external dependency.</p>
                </section>
                <section id="related-work"><h4><span class="section-heading">Related work</span><span class="section-anchor"> <a rel="bookmark" href="#related-work"><img width="24" height="24" src="assets/images/section-anchor.png" alt=""></a></span></h4>
                    <p><a href="https://www.iacr.org/cryptodb/data/paper.php?pubkey=218">Eliminating Random Permutation Oracles in the Even–Mansour Cipher</a></p>
                    <ul>
                        <li>This paper argues that a 4-round unkeyed Feistel is sufficient to replace a random permutation in the Even–Mansour cipher construction.</li>
                    </ul>
                    <p><a href="https://www.iacr.org/archive/crypto2000/18800377/18800377.pdf">On the Round Security of Symmetric-Key Cryptographic Primitives</a></p>
                    <p><a href="https://www.cl.cam.ac.uk/~rja14/Papers/bear-lion.pdf">LIONESS</a> is a similarly structured 4-round unbalanced Feistel cipher.</p>
                </section>
            </section>
        </section>
        <section id="reference-implementation"><h2><span class="section-heading">Reference implementation</span><span class="section-anchor"> <a rel="bookmark" href="#reference-implementation"><img width="24" height="24" src="assets/images/section-anchor.png" alt=""></a></span></h2>
            <ul>
                <li><a href="https://github.com/zcash/librustzcash/pull/352">https://github.com/zcash/librustzcash/pull/352</a></li>
                <li><a href="https://github.com/zcash/librustzcash/pull/416">https://github.com/zcash/librustzcash/pull/416</a></li>
            </ul>
        </section>
        <section id="acknowledgements"><h2><span class="section-heading">Acknowledgements</span><span class="section-anchor"> <a rel="bookmark" href="#acknowledgements"><img width="24" height="24" src="assets/images/section-anchor.png" alt=""></a></span></h2>
            <p>The authors would like to thank Benjamin Winston, Zooko Wilcox, Francisco Gindre, Marshall Gaucher, Joseph Van Geffen, Brad Miller, Deirdre Connolly, and Teor for discussions on the subject of Unified Addresses.</p>
        </section>
        <section id="references"><h2><span class="section-heading">References</span><span class="section-anchor"> <a rel="bookmark" href="#references"><img width="24" height="24" src="assets/images/section-anchor.png" alt=""></a></span></h2>
            <table id="rfc2119" class="footnote">
                <tbody>
                    <tr>
                        <th>1</th>
                        <td><a href="https://www.rfc-editor.org/rfc/rfc2119.html">RFC 2119: Key words for use in RFCs to Indicate Requirement Levels</a></td>
                    </tr>
                </tbody>
            </table>
            <table id="protocol-nu5" class="footnote">
                <tbody>
                    <tr>
                        <th>2</th>
                        <td><a href="protocol/nu5.pdf">Zcash Protocol Specification, Version 2020.1.24 or later [NU5 proposal]</a></td>
                    </tr>
                </tbody>
            </table>
            <table id="protocol-saplingpaymentaddrencoding" class="footnote">
                <tbody>
                    <tr>
                        <th>3</th>
                        <td><a href="protocol/nu5.pdf#saplingpaymentaddrencoding">Zcash Protocol Specification, Version 2020.1.24 [NU5 proposal]. Section 5.6.3.1: Sapling Payment Addresses</a></td>
                    </tr>
                </tbody>
            </table>
            <table id="protocol-orchardpaymentaddrencoding" class="footnote">
                <tbody>
                    <tr>
                        <th>4</th>
                        <td><a href="protocol/nu5.pdf#orchardpaymentaddrencoding">Zcash Protocol Specification, Version 2020.1.24 [NU5 proposal]. Section 5.6.4.2: Orchard Raw Payment Addresses</a></td>
                    </tr>
                </tbody>
            </table>
            <table id="zip-0211" class="footnote">
                <tbody>
                    <tr>
                        <th>5</th>
                        <td><a href="zip-0211">ZIP 211: Disabling Addition of New Value to the Sprout Chain Value Pool</a></td>
                    </tr>
                </tbody>
            </table>
            <table id="zip-0224" class="footnote">
                <tbody>
                    <tr>
                        <th>6</th>
                        <td><a href="zip-0224">ZIP 224: Orchard Shielded Protocol</a></td>
                    </tr>
                </tbody>
            </table>
            <table id="zip-0321" class="footnote">
                <tbody>
                    <tr>
                        <th>7</th>
                        <td><a href="zip-0321">ZIP 321: Payment Request URIs</a></td>
                    </tr>
                </tbody>
            </table>
            <table id="bip-0350" class="footnote">
                <tbody>
                    <tr>
                        <th>8</th>
                        <td><a href="https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki">BIP 350: Bech32m format for v1+ witness addresses</a></td>
                    </tr>
                </tbody>
            </table>
            <table id="p2pkh" class="footnote">
                <tbody>
                    <tr>
                        <th>9</th>
                        <td><a href="https://developer.bitcoin.org/devguide/transactions.html#p2pkh-script-validation">Transactions: P2PKH Script Validation — Bitcoin Developer Guide</a></td>
                    </tr>
                </tbody>
            </table>
            <table id="p2sh" class="footnote">
                <tbody>
                    <tr>
                        <th>10</th>
                        <td><a href="https://developer.bitcoin.org/devguide/transactions.html#pay-to-script-hash-p2sh">Transactions: P2SH Scripts — Bitcoin Developer Guide</a></td>
                    </tr>
                </tbody>
            </table>
        </section>
    </section>
</body>
</html>